<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Virtual development board: RoaLogic Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Virtual development board
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">RoaLogic Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h1><a class="anchor" id="vdbComponent7Seg"></a>
Virtual development 7 segment component</h1>
<h1><a class="anchor" id="vdbComponent_1"></a>
Virtual development board components</h1>
<p>Virtual development board components are components which have a specific system functionality, for example a LED. Meaning that there is a output of the system that connects with a LED, that LED is then shown on the GUI to the user. To set this up there are two different base designs, one basic module to connect with the verilated design and a module to show the state on the GUI. This is split for two reasons, one is that it's possible to have a component which is not connected to the verilated design or not shown on the GUI. Second reason is that it's possible to change the UI framework without having to change each component, this also helps with the two different threads for the verilated design and the GUI.</p>
<p>All vdb components shall be placed in the vdb directory and have there own submap named vdb&lt;component name&gt;. All design files shall be added in this subdirectory, where the classes that connect with the verilated design are called vdb&lt;component name&gt;. Classes that show something on the GUI are named differently, &lt;UI framework&gt;vdb&lt;component name&gt;.</p>
<p>As example the LED, placed in subdirectory vdbLED. It has the system verilog design in vdbLED.sv and the C++ sources that connect with the verilated design, <a class="el" href="vdbLED_8hpp_source.html">vdbLED.hpp</a> and vdbLED.cpp. The LED implementation for wxWidgets is placed in the <a class="el" href="wxWidgetsVdbLED_8hpp_source.html">wxWidgetsVdbLED.hpp</a> and wxWidgetVdbLED.cpp.</p>
<h1><a class="anchor" id="vdbComponent_2"></a>
virtual development board component basic module</h1>
<p>The virtual development board basic module is the module that directly connects with the verilated design. This can be done in two ways, first is by a specific system verilog design component that uses DPI functions. Second method is by directly checking the design itself. Preferred is to use the DPI methodology, as this simplifies and enhances design speed.</p>
<p>Since the base of each virtual development board component is the same, a generic base class is designed, see <a class="el" href="classRoaLogic_1_1vdb_1_1cVDBCommon.html">RoaLogic::vdb::cVDBCommon</a>. This is a header only class implementation which holds everything needed to communicate with a verilated component. To link a vdb component with a verilated design component, the verilated scope is used. This scope must be given during construction of the class, see &lt;add ref&gt; for more information about the scope of a verilated design.</p>
<p>When a verilated component has an event, like the toggling of an IO pin, a specific DPI function is called. However this DPI function only knows the scope of the design and not the corresponding class scope. Because of this the vdb common component holds a few static functions to handle the mapping of the scope and the pointer of the vdb component. All vdb components and their scope are stored statically, which is automaticcaly done during class creation and destruction.</p>
<p>DPI functions must call the processVerilatorEvent() with the scope of the event and possible event data. It traverses all the components to find the related scope, when found it calls the virtual verilatorCallback() function. In this function it has changed the context and we are now inside the class of the vdb component with the related event data. Since the verilatorCallback() function is pure virtual the derived class determines the implementation of the vdb component.</p>
<dl class="section note"><dt>Note</dt><dd>DPI functions shall be placed within the *.cpp file of the corresponding implementation. In this way the DPI functions are private and are not called within the design.</dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Every DPI function must call the processVerilatorEvent() function so that the system can handle the event accordingly.</dd></dl>
<h1><a class="anchor" id="vdbComponent_3"></a>
virtual development board component UI common</h1>
<p>Each UI component shall implement the <a class="el" href="classRoaLogic_1_1GUI_1_1cGuiVDBComponent.html" title="GUI virtual development board component.">RoaLogic::GUI::cGuiVDBComponent</a> base class. In this class all the basics are implemented to directly communicate with the vdb common component, which is passed during construction. There are cases where the verilated component is not used, a nullptr can at that point be given and the class will handle it accordingly.</p>
<p>The VDB common component does not care about the UI implementation and abstracts it away. This abstraction is created by the observer pattern and by using a virtual function. Both serve a different use case, since the vdb component does not know anything about the UI implementation, but the UI implementation does know the vdb common component, it can call the virtual cppEvent() function. With this data from the UI can be passed into the verilated context, where each component can override the cppEvent() and implement it's implementation.</p>
<p>From the verilated context to the UI is slightly more complicated, especially since each UI framework uses a different event mechanism. Because of this every vdb component shall implement a CSubject, so that any UI component can register to it. Every vdb component can now notify the UI component, which at that point can notify the UI framework with it's own event handling.</p>
<dl class="section attention"><dt>Attention</dt><dd>Due that UI components shall be updated within there own thread, the observer of the vdb component must handle the context switch from the verilator thread to the UI thread.</dd></dl>
<h1><a class="anchor" id="vdbComponent_4"></a>
virtual development board existing components</h1>
<p>LED: see <a class="el" href="namespaceRoaLogic.html#vdbComponentLED">Virtual development LED component</a> 7Segment display: see <a class="el" href="namespaceRoaLogic.html#vdbComponent7Seg">Virtual development 7 segment component</a> VGA: see <a class="el" href="/home/runner/work/virtualdevboard/virtualdevboard/src/common/vdb/vdbVGAMonitor/vdbVGAMonitor.hpp#vdbComponentVGA">Virtual development VGA component</a></p>
<h1><a class="anchor" id="vdbComponent_5"></a>
virtual development board component creating a new one</h1>
<h2><a class="anchor" id="Verilated"></a>
component</h2>
<p>A new VDB component which communicates with the verilated design is created by deriving from the cVDBCommon base class. The new class must then implement the void verilatorCallback(uint32_t event) function, which is called when an event from the verilated context occurs. In cases where it expects an event from the GUI, it must also implement the void cppEvent(uint32_t event) function. Eventual DPI functions are placed in the cpp file and shall call the verilatorCallback function, see example below. If there is a GUI component (which must register to the VDB component), we can notify it. If there is no component listening, the event will be ignored.</p>
<p>Example class definition: </p><div class="fragment"><div class="line"> {.c++}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceRoaLogic.html">RoaLogic</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">namespace </span>vdb </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">class </span>cMyNewVDBComponent : <span class="keyword">public</span> cVDBCommon</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">private</span>:</div>
<div class="line">        <span class="comment">// Define the verilator callback function</span></div>
<div class="line">        <span class="keywordtype">void</span> verilatorCallback(uint32_t event);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">        <span class="comment">// The constructor must have the scopename</span></div>
<div class="line">        cMyNewVDBComponent(std::string scopeName, uint8_t <span class="keywordtype">id</span>); </div>
<div class="line">        ~cMyNewVDBComponent();</div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceRoaLogic_html"><div class="ttname"><a href="namespaceRoaLogic.html">RoaLogic</a></div><div class="ttdef"><b>Definition:</b> distance.hpp:49</div></div>
</div><!-- fragment --><p>Example class implementation </p><div class="fragment"><div class="line"> {.c++}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This function is a implementation of the DPI function declared in the system verilog code</span></div>
<div class="line"><span class="keywordtype">void</span> myNewVDBComponentDPIFunction</div>
<div class="line">{</div>
<div class="line">     <span class="comment">// It calls the processVerilatorEvent function with the scope of the DPI function and</span></div>
<div class="line">     <span class="comment">// the value which is passed into the corresponding verilatorCallback function.</span></div>
<div class="line">     <a class="code hl_function" href="classRoaLogic_1_1vdb_1_1cVDBCommon.html#a542b3035f520c224933cd84d01fb548d">cVDBCommon::processVerilatorEvent</a>(svGetScope(), myValue);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceRoaLogic.html">RoaLogic</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>observer;</div>
<div class="line"><span class="keyword">namespace </span>vdb</div>
<div class="line">{</div>
<div class="line">     <span class="comment">// Construct the new class, internally everything is done within the cVDBCommon constructor</span></div>
<div class="line">     cMyNewVDBComponent::cMyNewVDBComponent(std::string scopeName, uint8_t <span class="keywordtype">id</span>) :</div>
<div class="line">         cVDBCommon(scopeName, id)</div>
<div class="line">     {</div>
<div class="line">         </div>
<div class="line">     } </div>
<div class="line"> </div>
<div class="line">     cMyNewVDBComponent::~cMyNewVDBComponent()</div>
<div class="line">     {</div>
<div class="line"> </div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> cMyNewVDBComponent::verilatorCallback(uint32_t event)</div>
<div class="line">    {</div>
<div class="line">         <span class="comment">// Handle the verilated event, which is up to the class to handle</span></div>
<div class="line"> </div>
<div class="line">         <span class="comment">// In case there is a GUI element, notify the observer and pass it the data</span></div>
<div class="line">         notifyObserver(eEvent::myNewEvent, myEventDataPointer);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
<div class="ttc" id="aclassRoaLogic_1_1vdb_1_1cVDBCommon_html_a542b3035f520c224933cd84d01fb548d"><div class="ttname"><a href="classRoaLogic_1_1vdb_1_1cVDBCommon.html#a542b3035f520c224933cd84d01fb548d">RoaLogic::vdb::cVDBCommon::processVerilatorEvent</a></div><div class="ttdeci">static void processVerilatorEvent(svScope scope, uint32_t event)</div><div class="ttdoc">Process a verilator event.</div><div class="ttdef"><b>Definition:</b> vdbCommon.hpp:397</div></div>
</div><!-- fragment --><h2><a class="anchor" id="GUI"></a>
component</h2>
<p>In this part we only explain the specifics of adding a GUI component within the system, this excludes the drawing part of the component as this is specific for each GUI framework. Each GUI component shall be derived from the cGuiVDBComponent. This baseclass holds all information to communicate with the VDB verilated component and to handle eventual calls from the GUI. The constructor takes a pointer to the VDB verilatored component, which can be given as nullptr in case it is not used. The class will internally register to the VDB component and receive the corresponding events in the notify() function. Since this function is specific to the component it is virtual and shall be overwritten by the derived class. The constructor also takes a distancePoint, which translates to the position on the GUI screen. This position is relative in dimension to the top left corner of the board screen. See &lt;add ref&gt; for more information. It is possible in some cases that the GUI has to clean up when the system is closed or restarted, for this reason there is a virtual onClose() function. This function is called when the component is closed to clean up, which is also depend on the implemented class.</p>
<p>Example class definition: </p><div class="fragment"><div class="line"> {.c++}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceRoaLogic.html">RoaLogic</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">namespace </span>GUI </div>
<div class="line">{</div>
<div class="line">    <span class="keyword">class </span>cNewGuiVdbComponent : <span class="keyword">public</span> cGuiVDBComponent, &lt;possible GUI framework base classes&gt;</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">private</span>:</div>
<div class="line">        <span class="comment">// Function to receive events from the vdb component</span></div>
<div class="line">        <span class="keywordtype">void</span> notify(eEvent aEvent, <span class="keywordtype">void</span>* data);</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">public</span>:</div>
<div class="line">        <span class="comment">// The constructor must have a pointer to the vdb component and a position on the screen</span></div>
<div class="line">        cNewGuiVdbComponent(cVDBCommon* myVDBComponent, distancePoint position); </div>
<div class="line">        ~cNewGuiVdbComponent();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Possible function if needed</span></div>
<div class="line">        <span class="keywordtype">void</span> onClose();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Functions needed by the GUI framework to draw something on the screen</span></div>
<div class="line">    };</div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>Example class implementation <div class="fragment"><div class="line"> {.c++}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span><a class="code hl_namespace" href="namespaceRoaLogic.html">RoaLogic</a></div>
<div class="line">{</div>
<div class="line">  <span class="keyword">using namespace </span>observer;</div>
<div class="line">  <span class="keyword">using namespace </span>dimensions;</div>
<div class="line"><span class="keyword">namespace </span>vdb</div>
<div class="line">{</div>
<div class="line">     <span class="comment">// Construct the new GUI class, internally everything is done within the cGuiVDBComponent constructor</span></div>
<div class="line">     cNewGuiVdbComponent::cNewGuiVdbComponent(cVDBCommon* myVDBComponent, distancePoint position) :</div>
<div class="line">         cGuiVDBComponent(myVDBComponent, position)</div>
<div class="line">     {</div>
<div class="line">         </div>
<div class="line">     } </div>
<div class="line"> </div>
<div class="line">     cNewGuiVdbComponent::~cNewGuiVdbComponent()</div>
<div class="line">     {</div>
<div class="line"> </div>
<div class="line">     }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> cNewGuiVdbComponent::notify(eEvent aEvent, <span class="keywordtype">void</span>* data)</div>
<div class="line">    {</div>
<div class="line">         <span class="comment">// Handle the event, which is up to this class to handle</span></div>
<div class="line">         <span class="comment">// Do note that this function runs in the verilated thread, we need to pass</span></div>
<div class="line">         <span class="comment">// the event to the GUI thread before we can adjust the GUI</span></div>
<div class="line">         postEventToGuiEventHandling(data);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">}</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="vdbComponentLED"></a>
Virtual development LED component</h1>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
